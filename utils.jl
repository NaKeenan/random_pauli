using Distributions
using TimerOutputs
using PauliStrings
const ps = PauliStrings
using Random
using JLD2
using Dates
using JSON


### Gate application functions ###

function apply_gate(O, P, θ; M=2^10, alt_trim=false, keep=Operator(0))
    @assert length(P.strings) == 1 "Gate must be generated by a single pauli generator"
    d = ps.emptydict(O)
    P = P.strings[1]
    for i in 1:length(O.strings)
        O_i, c_i = O.strings[i], O.coeffs[i]
        anticom = ps.anticommutator(O_i, P)

        if anticom[2] == 0
            c = c_i * cos(θ)
            ps.setwith!(+, d, O_i, c)
            p_n, k_n = ps.prod(P, O_i)

            c_n = sin(θ) * c_i * k_n * im
            ps.setwith!(+, d, p_n, c_n)
        
        else
            ps.setwith!(+, d, O_i, c_i)
        end

    end
    O_new = Operator(collect(keys(d)), collect(values(d)))
    O_new = ps.trim(O_new, M; keep=keep, keepnorm=false)
    return O_new
end

function apply_gate_list(O, gate_list, angle_list; M=2^10, noise=0, keep=Operator(0))
    for i in 1:length(gate_list)
        O = apply_gate(O, gate_list[i], angle_list[i], M=M, keep=keep)
    end
    O = ps.add_noise(O, noise)
    return O
end

### Construction ###

# Generate all local Z ops
function single_Z_operators(N)
    ops = Operator[]
    for i in 1:N
        O = Operator(N)
        O += "Z", i
        push!(ops, O)
    end
    return ops
end


function random_circuit(N, trial)
    angles = load_angles(N)[trial]
    gate_list = []
    angle_list = []

    for j in 1:2:N
        angles_bond = angles[j]
        θ1, θ2, Jx, Jz, θ3, θ4 = angles_bond["θ1"], angles_bond["θ2"], angles_bond["Jx"], angles_bond["Jz"], angles_bond["θ3"], angles_bond["θ4"]

        rot_1 = ps.Operator(N)
        rot_1 += "Z", j
        push!(gate_list, rot_1)
        push!(angle_list, θ1)

        rot_2 = ps.Operator(N)
        rot_2 += "Z", j+1
        push!(gate_list, rot_2)
        push!(angle_list, θ2)

        rot_xx = ps.Operator(N)
        rot_xx += "X", j, "X", j+1
        push!(gate_list, rot_xx)
        push!(angle_list, Jx)

        rot_yy = ps.Operator(N)
        rot_yy += "Y", j, "Y", j+1
        push!(gate_list, rot_yy)
        push!(angle_list, Jx)

        rot_zz = ps.Operator(N)
        rot_zz += "Z", j, "Z", j+1
        push!(gate_list, rot_zz)
        push!(angle_list, Jz)

        rot_3 = ps.Operator(N)
        rot_3 += "Z", j
        push!(gate_list, rot_3)
        push!(angle_list, θ3)

        rot_4 = ps.Operator(N)
        rot_4 += "Z", j+1
        push!(gate_list, rot_4)
        push!(angle_list, θ4)
    end

    for j in 2:2:N
        angles_bond = angles[j]
        θ1, θ2, Jx, Jz, θ3, θ4 = angles_bond["θ1"], angles_bond["θ2"], angles_bond["Jx"], angles_bond["Jz"], angles_bond["θ3"], angles_bond["θ4"]

        rot_1 = ps.Operator(N)
        rot_1 += "Z", j
        push!(gate_list, rot_1)
        push!(angle_list, θ1)

        rot_2 = ps.Operator(N)
        rot_2 += "Z", j%N+1
        push!(gate_list, rot_2)
        push!(angle_list, θ2)

        rot_xx = ps.Operator(N)
        rot_xx += "X", j, "X", j%N+1
        push!(gate_list, rot_xx)
        push!(angle_list, Jx)

        rot_yy = ps.Operator(N)
        rot_yy += "Y", j, "Y", j%N+1
        push!(gate_list, rot_yy)
        push!(angle_list, Jx)

        rot_zz = ps.Operator(N)
        rot_zz += "Z", j, "Z", j%N+1
        push!(gate_list, rot_zz)
        push!(angle_list, Jz)

        rot_3 = ps.Operator(N)
        rot_3 += "Z", j
        push!(gate_list, rot_3)
        push!(angle_list, θ3)

        rot_4 = ps.Operator(N)
        rot_4 += "Z", j%N+1
        push!(gate_list, rot_4)
        push!(angle_list, θ4)
    end
    return gate_list, angle_list
end

### Evolution ###

function load_angles(N::Int)
    filename = "random_archive/angles_N$(N).json"
    if !isfile(filename)
        error("File $filename does not exist.")
    end
    return JSON.parsefile(filename)
end

function two_point_correlators_random(N, num_steps, trial, O; M=2^10, noise=0, keep=Operator(0))
    correlators = []
    gate_list, angle_list = random_circuit(N, trial)
    all_local_Z = single_Z_operators(N)
    for t in 1:num_steps
        println("Time Step $t")
        correlators_t = [ps.trace_product(O, local_Z)/big(2)^N for local_Z in all_local_Z]
        push!(correlators, correlators_t)
        O = apply_gate_list(O, gate_list, angle_list; M=M, noise=noise, keep=keep)
    end
    return real.(correlators), angle_list
end;


function run_pauli_trial(N, num_steps, M, site, trial; save_dir="pauli_results")
    mkpath(save_dir)

    keep_op = ps.Operator(N)
    for local_Z in single_Z_operators(N)
        keep_op += local_Z
    end

    O = ps.Operator(N)
    O += "Z", site

    println("Running PauliStrings: N=$N, M=$M, site=$site, trial=$trial")

    to = TimerOutput()
    runtime = @elapsed begin
        @timeit to "Pauli evolution" begin
            results, angle_list = two_point_correlators_random(N, num_steps, trial, O; M=M, noise=0, keep=keep_op)
        end
    end

    # Construct metadata dictionary
    params = Dict(
        "N" => N,
        "num_steps" => num_steps,
        "M" => M,
        "site" => site,
        "trial" => trial,
        "runtime" => runtime,
        "timestamp" => Dates.now(),
        "save_dir" => save_dir,
        "angle_list" => angle_list
    )

    filepath = joinpath(save_dir, "pauli_M$(M)_site$(site)_trial$(trial).jld2")
    @save filepath results params

    return runtime
end
